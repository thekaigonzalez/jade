JADE (C)

    JADE - Just Another Decompiler Engine, by the Fake VOLT Foundation.

    A toolkit for optimizing, running, and emulating different bytecode formats.

    Contains the JADE VM, as well as VM definitions for OpenLUD, NexFUSE, and MercuryPIC.

JADE options:

    -m[arch...]         Run the code in either 32-bit or 8-bit mode
    -O[0|2|fast]        Optimizes the code depending on the level set
    -t                  Prints the code as English-itized text
    -g                  Interactively debugs the code
    
    -f                  Specifies a certain rule to go by.
                        * For example, `-frasterize` will run the code in RASter
                        (Registers Are Stacked) mode.
                        See ** RAS Mode ** for more information.

    -v                  Prints the JADE version
    -V                  Verbose mode

    -h                  Prints this help    

RAS Mode:

    RASter (Registers Are Stacked) mode is a mode of JADE that allows for
    faster and more efficient code generation.

    Historically, instead of using a stack, my bytecode VMs are primarily
    register based, meaning that to print a long value, it'd had to be stored in
    a register.

        MOV R1,'A'
        MOV R1,'B'
        MOV R1,'C'
    
    However with RASterizing, this changes. Now, by any means RASterizing is not
    for the faint of heart, as it is essentially the compiler and interpreter
    ignoring you, and ignoring the beautiful registers that exist.

    What does this mean? that the code above will not actually append values
    into registers, but instead they will be stored in a stack, and no registers
    or external memory will be used.

Optimization Levels:

    JADE contains 3 levels of optimizations, the default is -O2, with the option
    to disable optimization entirely, using `-O0`.

    -O2 is basic optimization, the default optimization, which contains
    macro-substitution and inlining. Macro-substitution is in the first level of
    optimization, where essentially every subroutine call is expanded into the
    subroutine body, as an example:

        SUB 1278
        ECHO 'A'
        ENDSUB
        
    can be called:

        JMP 1278

    And that code, in the regenerated code will end up being:

        ECHO 'A'

    Instead of a genuine JMP to 1278.

    Inlining is also a part of the first level of optimization. Inlining is the
    process of pre-compiling a static comparison statement into a single
    instruction.

    For example, the CMP instruction runs two subroutines:

        ; compare register 1 and 2, go to subroutine t if true, f if false
        CMP R1,R2,t,f

    And it essentially evaluates both registers and jumps to either t or f if
    they're not identical. Optimizing this code requires replacing the entire
    CMP instruction with a single, inlined CMP instruction:

        ; compare register 1 and 2, go to subroutine t if true, f if false
        ; inlined
        JMP t

    keep in mind that this optimization can potentially cause issues if the
    compilation order is changed, however, can increase speed because the base
    interpreter does not rely on the CMP instruction 

    -O0 disables all optimizations, good for emulation, and debugging. Does not
    fold anything

    -Ofast is the fastest possible optimization level and performs the most
    aggregate optimizations, including CMP-folding, inlining, macro
    substitution, and dead code elimintation.
